{
  "name": "PII Sanitization Chat Workflow",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "chat",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "1a1a1a1a-1111-1111-1111-111111111111",
      "name": "Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [
        464,
        240
      ],
      "webhookId": "chat-input"
    },
    {
      "parameters": {
        "jsCode": "// Session Management and Chat Processing with PII Protection\nconst request = $('Webhook').first().json.body;\nconst aiResponse = $input.first().json.message.content;\nconst sessionData = $('Session Manager').first().json;\n\n// Initialize global conversation memory if not exists\nglobal.conversations = global.conversations || {};\n\ntry {\n  // Use session data from Session Manager\n  const sessionId = sessionData.sessionId;\n  const turnCount = sessionData.turnCount;\n  \n  // Get existing conversation history\n  const conversation = global.conversations[sessionId] || {\n    messages: [],\n    persons: sessionData.existingPersons || {},\n    created_at: new Date().toISOString(),\n    last_active: new Date().toISOString(),\n    turn_count: 0\n  };\n  \n  console.log('DEBUG: Session', sessionId, 'Turn', turnCount);\n  \n  // Parse the AI response which contains both chat and PII data\n  const responseData = JSON.parse(aiResponse);\n  \n  // Update conversation turn count from Session Manager\n  conversation.turn_count = turnCount;\n  conversation.last_active = new Date().toISOString();\n  \n  // Process PII data if present and merge with existing persons\n  let mergedPersons = { ...conversation.persons };\n  let legacyMapping = {};\n  let tokenMap = {};\n  \n  if (responseData.pii_analysis && responseData.pii_analysis.persons) {\n    const piiData = responseData.pii_analysis;\n    \n    // Merge new persons with existing ones\n    Object.keys(piiData.persons).forEach(personId => {\n      if (mergedPersons[personId]) {\n        // Update existing person\n        const existing = mergedPersons[personId];\n        const newPerson = piiData.persons[personId];\n        \n        // Merge arrays and update metadata\n        existing.emails = [...new Set([...existing.emails, ...newPerson.emails])];\n        existing.phones = [...new Set([...existing.phones, ...newPerson.phones])];\n        existing.addresses = [...new Set([...existing.addresses, ...newPerson.addresses])];\n        existing.aliases = [...new Set([...existing.aliases, ...newPerson.aliases])];\n        if (newPerson.ids) existing.ids = [...new Set([...(existing.ids || []), ...newPerson.ids])];\n        \n        existing.metadata.last_seen = new Date().toISOString();\n        existing.metadata.session_count = conversation.turn_count;\n      } else {\n        // Add new person\n        mergedPersons[personId] = {\n          ...piiData.persons[personId],\n          metadata: {\n            ...piiData.persons[personId].metadata,\n            first_seen: new Date().toISOString(),\n            last_seen: new Date().toISOString(),\n            session_count: conversation.turn_count\n          }\n        };\n      }\n    });\n    \n    // Create legacy mapping and token map\n    if (piiData.token_map) {\n      tokenMap = piiData.token_map;\n      Object.keys(piiData.token_map).forEach(token => {\n        const personId = token.match(/\\[([^\\]:]+)/)?.[1];\n        const fieldPath = piiData.token_map[token];\n        if (personId && mergedPersons[personId]) {\n          const person = mergedPersons[personId];\n          if (fieldPath === 'primary_name') {\n            legacyMapping[token] = person.primary_name;\n          } else if (fieldPath.startsWith('emails[')) {\n            const index = parseInt(fieldPath.match(/\\[(\\d+)\\]/)?.[1] || '0');\n            legacyMapping[token] = person.emails[index] || '';\n          } else if (fieldPath.startsWith('phones[')) {\n            const index = parseInt(fieldPath.match(/\\[(\\d+)\\]/)?.[1] || '0');\n            legacyMapping[token] = person.phones[index] || '';\n          } else if (fieldPath.startsWith('addresses[')) {\n            const index = parseInt(fieldPath.match(/\\[(\\d+)\\]/)?.[1] || '0');\n            legacyMapping[token] = person.addresses[index] || '';\n          } else if (fieldPath.startsWith('ids[')) {\n            const index = parseInt(fieldPath.match(/\\[(\\d+)\\]/)?.[1] || '0');\n            legacyMapping[token] = person.ids[index] || '';\n          }\n        }\n      });\n    }\n  }\n  \n  // Add sanitized message to conversation history\n  conversation.messages.push({\n    role: 'user',\n    content: responseData.pii_analysis?.sanitized_text || request.message,\n    timestamp: new Date().toISOString(),\n    turn: conversation.turn_count\n  });\n  \n  conversation.messages.push({\n    role: 'assistant', \n    content: responseData.chat_response,\n    timestamp: new Date().toISOString(),\n    turn: conversation.turn_count\n  });\n  \n  // Update conversation persons\n  conversation.persons = mergedPersons;\n  \n  // Store updated conversation (memory-based)\n  global.conversations[sessionId] = conversation;\n  \n  // Clean up old sessions (keep last 100)\n  const sessionKeys = Object.keys(global.conversations);\n  if (sessionKeys.length > 100) {\n    const sortedSessions = sessionKeys.sort((a, b) => \n      new Date(global.conversations[b].last_active) - new Date(global.conversations[a].last_active)\n    );\n    sortedSessions.slice(100).forEach(key => delete global.conversations[key]);\n  }\n  \n  return {\n    json: {\n      sessionId: sessionId,\n      chat_response: responseData.chat_response,\n      conversation_turn: conversation.turn_count,\n      persons: mergedPersons,\n      token_map: tokenMap,\n      pii_mapping: legacyMapping,\n      sanitized_text: responseData.pii_analysis?.sanitized_text || request.message,\n      original_input: request.message,\n      timestamp: new Date().toISOString(),\n      conversation_length: conversation.messages.length\n    }\n  };\n  \n} catch (error) {\n  console.log(\"ERROR: \" + error);\n  console.log(\"RAW AI RESPONSE: \" + aiResponse);\n  return {\n    json: {\n      error: 'Failed to process chat response',\n      raw_response: aiResponse,\n      original_input: request.message,\n      session_id: request.session_id || 'error_session'\n    }\n  };\n}"
      },
      "id": "3c3c3c3c-3333-3333-3333-333333333333",
      "name": "Process PII Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1040,
        240
      ]
    },
    {
      "parameters": {
        "jsCode": "// Session Lookup and Conversation History Management\nconst request = $('Webhook').first().json.body;\n\n// Initialize global conversation memory if not exists\nglobal.conversations = global.conversations || {};\n\n// Get or create session ID\nlet sessionId = request.session_id;\nif (!sessionId) {\n  sessionId = 'chat_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);\n}\n\n// Get existing conversation\nconst conversation = global.conversations[sessionId] || {\n  messages: [],\n  persons: {},\n  created_at: new Date().toISOString(),\n  last_active: new Date().toISOString(),\n  turn_count: 0\n};\n\n// Build conversation history for AI context (last 10 messages)\nconst recentHistory = conversation.messages.slice(-10);\nlet conversationContext = '';\nif (recentHistory.length > 0) {\n  conversationContext = '\\n\\nConversation History:\\n' + \n    recentHistory.map(msg => `${msg.role}: ${msg.content}`).join('\\n');\n}\n\nconsole.log('DEBUG: Session lookup for', sessionId, 'with', conversation.messages.length, 'previous messages');\n\nreturn {\n  json: {\n    sessionId: sessionId,\n    message: request.message,\n    conversationContext: conversationContext,\n    turnCount: conversation.turn_count + 1,\n    existingPersons: conversation.persons\n  }\n};"
      },
      "id": "5e5e5e5e-5555-5555-5555-555555555555",
      "name": "Session Manager",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        580,
        240
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": {
          "status": "success",
          "session_id": "={{ $json.sessionId }}",
          "chat_response": "={{ $json.chat_response }}",
          "conversation_turn": "={{ $json.conversation_turn }}",
          "conversation_length": "={{ $json.conversation_length }}",
          "sanitized_text": "={{ $json.sanitized_text }}",
          "persons": "={{ $json.persons }}",
          "token_map": "={{ $json.token_map }}",
          "pii_mapping": "={{ $json.pii_mapping }}",
          "original_input": "={{ $json.original_input }}",
          "timestamp": "={{ $json.timestamp }}"
        },
        "options": {}
      },
      "id": "4d4d4d4d-4444-4444-4444-444444444444",
      "name": "Webhook Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        1264,
        240
      ]
    },
    {
      "parameters": {
        "modelId": {
          "__rl": true,
          "value": "gpt-5",
          "mode": "list",
          "cachedResultName": "GPT-5"
        },
        "messages": {
          "values": [
            {
              "content": "You are an AI assistant with dual capabilities: natural conversation AND PII detection/tokenization.\n\nYour task:\n1. Provide a helpful, natural chat response to the user\n2. Detect and tokenize any PII in the user's message\n3. Maintain conversation context and refer to people by their tokens\n\nPII Tokenization Rules:\n- Names: [Person1], [Person2], etc. (sequential, persistent across conversation)\n- Emails: [Person1:email1], [Person1:email2] \n- Phones: [Person1:phone1], [Person1:phone2]\n- Addresses: [Person1:address1], [Person1:address2]\n- IDs/SSNs: [Person1:id1], [Person1:id2]\n\nEXTREMELY IMPORTANT: Return ONLY this EXACT JSON structure:\n{\n  \"chat_response\": \"Natural conversational response using tokens for any people mentioned\",\n  \"pii_analysis\": {\n    \"sanitized_text\": \"User's message with PII replaced by tokens\",\n    \"persons\": {\n      \"Person1\": {\n        \"primary_name\": \"actual name\",\n        \"aliases\": [],\n        \"emails\": [\"actual@email.com\"],\n        \"phones\": [\"actual-phone\"],\n        \"addresses\": [\"actual address\"],\n        \"relationships\": {},\n        \"metadata\": {\n          \"confidence_score\": 0.95,\n          \"first_seen\": \"2025-09-16T22:00:00.000Z\",\n          \"last_seen\": \"2025-09-16T22:00:00.000Z\",\n          \"session_count\": 1\n        }\n      }\n    },\n    \"token_map\": {\n      \"[Person1]\": \"primary_name\",\n      \"[Person1:email1]\": \"emails[0]\",\n      \"[Person1:phone1]\": \"phones[0]\",\n      \"[Person1:address1]\": \"addresses[0]\"\n    }\n  }\n}\n\nIf no PII is detected, still provide the chat_response but set pii_analysis to {\"sanitized_text\": \"original message\", \"persons\": {}, \"token_map\": {}}.",
              "role": "system"
            },
            {
              "content": "={{ 'Current user message: ' + $json.message + $json.conversationContext }}"
            }
          ]
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 1.8,
      "position": [
        688,
        240
      ],
      "id": "440d9a5b-f403-4122-ae77-91b2cedf281b",
      "name": "Message a model",
      "credentials": {
        "openAiApi": {
          "id": "BGcTbTUCTxCVCepx",
          "name": "OpenAi account"
        }
      }
    }
  ],
  "pinData": {},
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "Session Manager",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Session Manager": {
      "main": [
        [
          {
            "node": "Message a model",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process PII Data": {
      "main": [
        [
          {
            "node": "Webhook Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Message a model": {
      "main": [
        [
          {
            "node": "Process PII Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "de2f9bd7-1ab9-43ce-8e45-0ea3132bc8dd",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "060dac1fefe5feb9865b0fb3a4e242ee059b33980a03587a868224adc8c1d561"
  },
  "id": "1",
  "tags": []
}